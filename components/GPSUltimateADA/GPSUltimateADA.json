{
    "Parts": [
        {
            "name": "GPSUltimateADA",
            "symbol": {
                "ref": "https://ucarecdn.com/dfd74d4d-2375-40ba-9b48-9e031879925f/"
            },
            "displayName": "Adafruit Ultimate GPS Breakout - 66 channel w/10 Hz updates - Version 3",
            "category": [
                "input"
            ],
            "desc": "",
            "bom": [
                {
                    "name": "octopart",
                    "image": "https://ucarecdn.com/2c6e3705-96c9-4dc0-9cb1-de3813862917/",
                    "link": "https://octopart.com/746-adafruit+industries-32978860",
                    "price": "39.95",
                    "SKU": "1528-1153-ND"
                }
            ],
            "info": {
                "setup": "",
                "test": ""
            },
            "placing": {
                "onBreadboard": true
            }
        }
    ],
    "Blocks": [
        {
            "name": "GPSUltimateADA",
            "path": "GPSUltimateADA",
            "category": "input",
            "blockId": "488167",
            "app": {
                "appName": "Adafruit Ultimate GPS Breakout - 66 channel w/10 Hz updates - Version 3",
                "numericName": "",
                "shortName": "Ultimate GPS",
                "tags": [
                    "inputs"
                ],
                "indicators": {
                    "verified": "false",
                    "code": "true",
                    "solder": "true"
                },
                "desc": "<p>A high-quality GPS module that can track up to 22 satellites on 66 channels. It has an excellent high-sensitivity receiver (-165 dB ) and a built in antenna. It can do up to 10 location updates a second for high speed, high sensitivity logging or tracking. The module has low power consumption, to save some more power use the ENABLE pin to disable the module.Thanks to the on-board voltage level shifter the module is 5v tolerant.It also has an on board coin cell slot for the RTC to run and allow warm starts, an external antenna connector and a built in data logger.</p>",
                "visible": "true"
            },
            "requires": [
                [
                    0,
                    [
                        "GPSUltimateADA_HardwareSerial"
                    ]
                ],
                [
                    100,
                    [
                        "GPSUltimateADA_SoftwareSerial"
                    ]
                ]
            ],
            "supportedControllers": [],
            "circuit": {}
        },
        {
            "name": "GPSUltimateADA_HardwareSerial",
            "path": "GPSUltimateADA",
            "category": "input",
            "blockId": "!488167",
            "coders": [
                "GPSUltimateADA_HardwareSerial"
            ],
            "supportedControllers": [
                "ArduinoLeonardo",
                "ArduinoMega",
                "ArduinoMicro",
                "ESP32DevKitC",
                "RPI3B"
            ],
            "circuit": {
                "parts": [
                    {
                        "name": "this",
                        "part": "GPSUltimateADA"
                    }
                ],
                "ports": [
                    {
                        "name": "VIN",
                        "interface": {
                            "requires":[[0,["3.3v"]],[1,["5v"]]],
                            "requiresLoad": 25
                        }
                    },
                    {
                        "name": "GND",
                        "interface": {
                            "requires":[[0,["GND"]]]
                        }
                    },
                    {
                        "name": "RX",
                        "interface": {
                            "requires":[[0,["3.3v","TX"]],[1,["5v","TX"]]],
                            "unique": true
                        }
                    },
                    {
                        "name": "TX",
                        "interface": {
                            "requires":[[0,["3.3v","RX"]],[1,["5v","RX"]]],
                            "unique": true
                        }
                    },
                    {
                        "name": "supportedControllers",
                        "interface": {
                            "requires":[[0,["ArduinoMega"]],[1,["ArduinoMicro"]],[2,["ArduinoLeonardo"]],[3,["RPI3B"]],[4,["ESP32DevKitC"]]]
                        }
                    }
                ]
            }
        },
        {
            "name": "GPSUltimateADA_SoftwareSerial",
            "path": "GPSUltimateADA",
            "category": "input",
            "blockId": "!488167",
            "coders": [
                "GPSUltimateADA_SoftwareSerial"
            ],
            "supportedControllers": [
                "ATMega328P",
                "ArduinoGemma",
                "ArduinoLeonardo",
                "ArduinoMega",
                "ArduinoMicro",
                "ArduinoNano",
                "ArduinoProMini3v3",
                "ArduinoProMini5v",
                "ArduinoUno",
                "NodeMCU"
            ],
            "circuit": {
                "parts": [
                    {
                        "name": "this",
                        "part": "GPSUltimateADA"
                    }
                ],
                "ports": [
                    {
                        "name": "SerialType",
                        "interface": {
                            "requires":[[0,["ESPSoftwareSerialTag"]]]
                        }
                    },
                    {
                        "name": "VIN",
                        "interface": {
                            "requires":[[0,["3.3v"]],[1,["5v"]]],
                            "requiresLoad": 25
                        }
                    },
                    {
                        "name": "GND",
                        "interface": {
                            "requires":[[0,["GND"]]]
                        }
                    },
                    {
                        "name": "RX",
                        "interface": {
                            "requires":[[0,["3.3v","ESPSoftwareSerialTX"]],[1,["5v","ESPSoftwareSerialTX"]],[2,["3.3v","ESPSoftwareSerialTX1"]],[3,["5v","ESPSoftwareSerialTX1"]]],
                            "unique": true
                        }
                    },
                    {
                        "name": "TX",
                        "interface": {
                            "requires":[[0,["3.3v","ESPSoftwareSerialRX"]],[1,["5v","ESPSoftwareSerialRX"]],[2,["3.3v","ESPSoftwareSerialRX1"]],[3,["5v","ESPSoftwareSerialRX1"]]],
                            "unique": true
                        }
                    },
                    {
                        "name": "supportedControllers",
                        "interface": {
                            "requires":[[0,["ArduinoUno"]],[1,["ArduinoMega"]],[2,["ArduinoMicro"]],[3,["ArduinoProMini5v"]],[4,["ArduinoProMini3v3"]],[5,["ArduinoLeonardo"]],[6,["ArduinoNano"]],[7,["NodeMCU"]],[8,["ArduinoGemma"]],[9,["ATMega328P"]]]
                        }
                    }
                ]
            }
        }
    ],
    "Coders": [
        {
            "name": "GPSUltimateADA_HardwareSerial",
            "supportedControllers": [
                "ArduinoLeonardo",
                "ArduinoMega",
                "ArduinoMicro",
                "ESP32DevKitC",
                "RPI3B"
            ],
            "code": {
                "global:": "    #define GPSECHO  true\n    uint32_t timer = millis(); //timer to read & print out the current stats\n    boolean usingInterrupt = false; // off by default! this keeps track of whether we're using the interrupt\n",
                "constructors:": "    HardwareSerial& gpsSerial(Serial1);\n    {{classname}} {{varname}}(&gpsSerial);\n",
                "setup:": "  {{varname}}.init();\n",
                "snippetCode:": "  if (! usingInterrupt) {\n      // read data from the GPS in the 'main loop'\n      char c = {{varname}}.read();\n      // if you want to debug, this is a good time to do it!\n      if (GPSECHO)\n        if (c) Serial.print(c);\n    }\n    // if a sentence is received, we can check the checksum, parse it...\n    if ({{varname}}.newNMEAreceived()) {\n      // a tricky thing here is if we print the NMEA sentence, or data\n      // we end up not listening and catching other sentences!\n      // so be very wary if using OUTPUT_ALLDATA and trytng to print out data\n      //Serial.println({{varname}}.lastNMEA());   // this also sets the newNMEAreceived() flag to false\n      if (!{{varname}}.parse({{varname}}.lastNMEA()))   // this also sets the newNMEAreceived() flag to false\n        return;  // we can fail to parse a sentence in which case we should just wait for another\n    }\n    // if millis() or timer wraps around, we'll just reset it\n    if (timer > millis())  timer = millis();\n    // approximately every 2 seconds or so, print out the current stats\n    if (millis() - timer > 2000) {\n      timer = millis(); // reset the timer\n      Serial.print(\"\\nTime: \");\n      Serial.print({{varname}}.hour, DEC); Serial.print(':');\n      Serial.print({{varname}}.minute, DEC); Serial.print(':');\n      Serial.print({{varname}}.seconds, DEC); Serial.print('.');\n      Serial.println({{varname}}.milliseconds);\n      Serial.print(\"Date: \");\n      Serial.print({{varname}}.day, DEC); Serial.print('/');\n      Serial.print({{varname}}.month, DEC); Serial.print(\"/20\");\n      Serial.println({{varname}}.year, DEC);\n      Serial.print(\"Fix: \"); Serial.print((int){{varname}}.fix);\n      Serial.print(\" quality: \"); Serial.println((int){{varname}}.fixquality);\n      if ({{varname}}.fix) {\n        Serial.print(\"Location: \");\n        Serial.print({{varname}}.latitude, 4); Serial.print({{varname}}.lat);\n        Serial.print(\", \");\n        Serial.print({{varname}}.longitude, 4); Serial.println({{varname}}.lon);\n        Serial.print(\"Location (in degrees, works with Google Maps): \");\n        Serial.print({{varname}}.latitudeDegrees, 4);\n        Serial.print(\", \");\n        Serial.println({{varname}}.longitudeDegrees, 4);\n        Serial.print(\"Speed (knots): \"); Serial.println({{varname}}.speed);\n        Serial.print(\"Angle: \"); Serial.println({{varname}}.angle);\n        Serial.print(\"Altitude: \"); Serial.println({{varname}}.altitude);\n        Serial.print(\"Satellites: \"); Serial.println((int){{varname}}.satellites);\n      }\n    }"
            },
            "license": "BSD",
            "instantiate": {
                "classname": "Adafruit_GPS",
                "varname": "GPS"
            },
            "files": [
                "lib/*.*"
            ]
        },
        {
            "name": "GPSUltimateADA_SoftwareSerial",
            "supportedControllers": [
                "ATMega328P",
                "ArduinoGemma",
                "ArduinoLeonardo",
                "ArduinoMega",
                "ArduinoMicro",
                "ArduinoNano",
                "ArduinoProMini3v3",
                "ArduinoProMini5v",
                "ArduinoUno",
                "NodeMCU"
            ],
            "code": {
                "global:": "    #define GPSECHO  true\n    uint32_t timer = millis(); //timer to read & print out the current stats\n    boolean usingInterrupt = false; // off by default! this keeps track of whether we're using the interrupt\n",
                "constructors:": "    SoftwareSerial gpsSerial({{TX}},{{RX}});\n    {{classname}} {{varname}}(&gpsSerial);\n",
                "setup:": "  {{varname}}.init();\n",
                "snippetCode:": "  if (! usingInterrupt) {\n      // read data from the GPS in the 'main loop'\n      char c = {{varname}}.read();\n      // if you want to debug, this is a good time to do it!\n      if (GPSECHO)\n        if (c) Serial.print(c);\n    }\n    // if a sentence is received, we can check the checksum, parse it...\n    if ({{varname}}.newNMEAreceived()) {\n      // a tricky thing here is if we print the NMEA sentence, or data\n      // we end up not listening and catching other sentences!\n      // so be very wary if using OUTPUT_ALLDATA and trytng to print out data\n      //Serial.println({{varname}}.lastNMEA());   // this also sets the newNMEAreceived() flag to false\n      if (!{{varname}}.parse({{varname}}.lastNMEA()))   // this also sets the newNMEAreceived() flag to false\n        return;  // we can fail to parse a sentence in which case we should just wait for another\n    }\n    // if millis() or timer wraps around, we'll just reset it\n    if (timer > millis())  timer = millis();\n    // approximately every 2 seconds or so, print out the current stats\n    if (millis() - timer > 2000) {\n      timer = millis(); // reset the timer\n      Serial.print(\"\\nTime: \");\n      Serial.print({{varname}}.hour, DEC); Serial.print(':');\n      Serial.print({{varname}}.minute, DEC); Serial.print(':');\n      Serial.print({{varname}}.seconds, DEC); Serial.print('.');\n      Serial.println({{varname}}.milliseconds);\n      Serial.print(\"Date: \");\n      Serial.print({{varname}}.day, DEC); Serial.print('/');\n      Serial.print({{varname}}.month, DEC); Serial.print(\"/20\");\n      Serial.println({{varname}}.year, DEC);\n      Serial.print(\"Fix: \"); Serial.print((int){{varname}}.fix);\n      Serial.print(\" quality: \"); Serial.println((int){{varname}}.fixquality);\n      if ({{varname}}.fix) {\n        Serial.print(\"Location: \");\n        Serial.print({{varname}}.latitude, 4); Serial.print({{varname}}.lat);\n        Serial.print(\", \");\n        Serial.print({{varname}}.longitude, 4); Serial.println({{varname}}.lon);\n        Serial.print(\"Location (in degrees, works with Google Maps): \");\n        Serial.print({{varname}}.latitudeDegrees, 4);\n        Serial.print(\", \");\n        Serial.println({{varname}}.longitudeDegrees, 4);\n        Serial.print(\"Speed (knots): \"); Serial.println({{varname}}.speed);\n        Serial.print(\"Angle: \"); Serial.println({{varname}}.angle);\n        Serial.print(\"Altitude: \"); Serial.println({{varname}}.altitude);\n        Serial.print(\"Satellites: \"); Serial.println((int){{varname}}.satellites);\n      }\n    }"
            },
            "license": "BSD",
            "instantiate": {
                "classname": "Adafruit_GPS",
                "ports": [
                    "RX",
                    "TX"
                ],
                "varname": "gpsAdafuit"
            },
            "files": [
                "lib/*.*"
            ],
            "includeHeaders": [
                "SoftwareSerial.h",
                "Adafruit_GPS.h"
            ]
        }
    ]
}