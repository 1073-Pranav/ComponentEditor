{
    "name": "GPSUltimateADA_HardwareSerial",
    "supportedControllers": [
        "ArduinoLeonardo",
        "ArduinoMega",
        "ArduinoMicro",
        "ESP32DevKitC",
        "RPI3B"
    ],
    "code": {
        "global": "    #define GPSECHO  true\n    uint32_t timer = millis(); //timer to read & print out the current stats\n    boolean usingInterrupt = false; // off by default! this keeps track of whether we're using the interrupt\n",
        "constructors": "    HardwareSerial& gpsSerial(Serial1);\n    {{classname}} {{varname}}(&gpsSerial);\n",
        "setup": "  {{varname}}.init();\n",
        "snippetCode": "  if (! usingInterrupt) {\n      // read data from the GPS in the 'main loop'\n      char c = {{varname}}.read();\n      // if you want to debug, this is a good time to do it!\n      if (GPSECHO)\n        if (c) Serial.print(c);\n    }\n    // if a sentence is received, we can check the checksum, parse it...\n    if ({{varname}}.newNMEAreceived()) {\n      // a tricky thing here is if we print the NMEA sentence, or data\n      // we end up not listening and catching other sentences!\n      // so be very wary if using OUTPUT_ALLDATA and trytng to print out data\n      //Serial.println({{varname}}.lastNMEA());   // this also sets the newNMEAreceived() flag to false\n      if (!{{varname}}.parse({{varname}}.lastNMEA()))   // this also sets the newNMEAreceived() flag to false\n        return;  // we can fail to parse a sentence in which case we should just wait for another\n    }\n    // if millis() or timer wraps around, we'll just reset it\n    if (timer > millis())  timer = millis();\n    // approximately every 2 seconds or so, print out the current stats\n    if (millis() - timer > 2000) {\n      timer = millis(); // reset the timer\n      Serial.print(\"\\nTime: \");\n      Serial.print({{varname}}.hour, DEC); Serial.print(':');\n      Serial.print({{varname}}.minute, DEC); Serial.print(':');\n      Serial.print({{varname}}.seconds, DEC); Serial.print('.');\n      Serial.println({{varname}}.milliseconds);\n      Serial.print(\"Date: \");\n      Serial.print({{varname}}.day, DEC); Serial.print('/');\n      Serial.print({{varname}}.month, DEC); Serial.print(\"/20\");\n      Serial.println({{varname}}.year, DEC);\n      Serial.print(\"Fix: \"); Serial.print((int){{varname}}.fix);\n      Serial.print(\" quality: \"); Serial.println((int){{varname}}.fixquality);\n      if ({{varname}}.fix) {\n        Serial.print(\"Location: \");\n        Serial.print({{varname}}.latitude, 4); Serial.print({{varname}}.lat);\n        Serial.print(\", \");\n        Serial.print({{varname}}.longitude, 4); Serial.println({{varname}}.lon);\n        Serial.print(\"Location (in degrees, works with Google Maps): \");\n        Serial.print({{varname}}.latitudeDegrees, 4);\n        Serial.print(\", \");\n        Serial.println({{varname}}.longitudeDegrees, 4);\n        Serial.print(\"Speed (knots): \"); Serial.println({{varname}}.speed);\n        Serial.print(\"Angle: \"); Serial.println({{varname}}.angle);\n        Serial.print(\"Altitude: \"); Serial.println({{varname}}.altitude);\n        Serial.print(\"Satellites: \"); Serial.println((int){{varname}}.satellites);\n      }\n    }"
    },
    "license": "BSD",
    "instantiate": {
        "classname": "Adafruit_GPS",
        "varname": "GPS"
    },
    "files": [
        "h.h",
        "cpp.cpp"
    ]
}